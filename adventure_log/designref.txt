t (18/11/19)
+ note (Modelling the input/output model so far)
    + diag (
        what we have now

            /  style:           \
            | Process Name      |
            \    Input > Output /

            defects4j.test
                [defects4j_project_dir, testname, testmethod] > success/failed

            defects4j.coverage
                [defects4j_project_dir, testname, testmethod, list_of_classes] > coverage.xml

            get_method_coverage.py (after coverage done on the project)
                defects4j_project_dir > list_of_methods

            SingleTestRunner.java
                [defects4j_project_dir, testname, testmethod]] > success/failed
        )

    + diag (
        what data is needed

            for overall
                list of test, and its fail/success status
                list of method run by a failed test
            
            for Clustering
                matrix/table of [methods] x [testcase] with value of 0/1

            for Daikon
                [methods] + [subset of passed testcases]
        )

t (19/11/19)
+ steps towards Clustering
    +1 run defects4j test for all test on a buggy program
    +2 get the failed test
    +3 collect all classes in the program
    +4 instrument all of the classes
    +5 run coverage test of the failed tests
    +6 we get all method that is run only by the failed test, make a list of em
    +7 get all the classes containing all those methods
    +8 now instrument only them
    +9 run coverage test of the passing tests
    +10 take note whether each method is run by the passing test or not
    +11 make a matrix or table for the final output

t (25/11/19)
+ defects4j randoop_coverage.sh i/o + process analysis
    diag (

        randoop_coverage.sh
            [p_id, b_id] > coverage.xml and statistics (write to file)
 
            process
                + do preprocess stuff
                + call run_randoop.pl on specified p_id + b_id
                + run test_coverage on gen'd test suites

        (we don't need Randoop as for now)

        test_coverage (located in test.include)
            [p_id, b_id] > none

            process
                + do preprocess stuff
                + call run_coverage.pl
                + check the results for each test suites

        run_coverage.pl
            [p_id, b_id, suite] > coverage analysis (write to file)

            process
                + do preprocess
                + call Coverage::coverage_ext
    )
